# -*- coding: utf-8 -*-
"""Nguyễn Lê Minh Trí - CTDL&GT - K4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10tuNchEzHwZVG8sQqFw-zRSa84WQ3Sw0

**1. Giải thuật đệ quy**

**BT01** Tháp Hà Nội
"""

def TowerofHanoi(n, source, destination, auxiliary):
    if n==1:
        print("Chuyển đĩa 1 từ cọc",source,"sang   cọc",destination)
        return
    TowerofHanoi(n-1,source,auxiliary,destination)
    print("Chuyển đĩa",n,"từ cọc",source,"sang cọc",destination)
    TowerofHanoi(n-1,auxiliary,destination,source)

n =int(input("Nhập vào: "))
A= input("Nhập vào cột đặt: ")
B= input("Nhập vào cột mục tiêu: ")
C= input("Nhập vào cột trung gian: ")
TowerofHanoi(n,A,B,C)

"""**BT02** Ước số chung lớn nhất"""

def gcd(a,b):
    if b == 0:
        return a
    else:
        return gcd(b,a%b)

a=int(input("Nhập vào số a: "))
b=int(input("Nhập vào số b: "))
print(gcd(a,b))

"""**BT03** Bội chung nhỏ nhất"""

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return abs(a * b) // gcd(a, b)

# Ví dụ sử dụng
a = 15
b = 20
print(f"BCNN của {a} và {b} là {lcm(a, b)}")

"""**BT04** Tính giai thừa một số"""

def factorial(n):
    if n == 0:
        return 1
    else:
        return n*factorial(n-1)

n=int(input("Nhập vào số cần tính giai thừa: "))
a=factorial(n)
print(a)

"""**BT05** Bài toán mã đi tuần"""

def is_valid_move(x, y, sol, N):
    """
    Kiểm tra nước đi có hợp lệ hay không
    """
    return x >= 0 and y >= 0 and x < N and y < N and sol[x][y] == -1


def print_solution(sol):
    """
    In ra ma trận giải pháp
    """
    for row in sol:
        print(row)


def solve_knight_tour(N):
    """
    Tìm giải pháp cho bài toán mã đi tuần bằng backtracking
    """
    # Khởi tạo ma trận giải pháp
    sol = [[-1 for _ in range(N)] for _ in range(N)]

    # Khởi tạo vị trí bắt đầu là (0, 0)
    sol[0][0] = 0

    # Khởi tạo 2 mảng lưu tọa độ các bước đi của mã
    x_move = [2, 1, -1, -2, -2, -1, 1, 2]
    y_move = [1, 2, 2, 1, -1, -2, -2, -1]

    # Bắt đầu tìm kiếm giải pháp
    if not solve_knight_tour_util(0, 0, 1, sol, x_move, y_move, N):
        print("Không tìm thấy giải pháp")
    else:
        print_solution(sol)


def solve_knight_tour_util(x, y, move_num, sol, x_move, y_move, N):
    """
    Hàm đệ quy để tìm kiếm giải pháp
    """
    # Kiểm tra xem đã đi hết các ô trên bàn cờ chưa
    if move_num == N * N:
        return True

    # Duyệt qua các bước đi của mã
    for i in range(8):
        next_x = x + x_move[i]
        next_y = y + y_move[i]

        # Kiểm tra nước đi có hợp lệ hay không
        if is_valid_move(next_x, next_y, sol, N):
            # Đánh dấu ô hiện tại là đã đi qua
            sol[next_x][next_y] = move_num
                # Gọi đệ quy để tìm giải pháp tiếp theo
            if solve_knight_tour_util(next_x, next_y, move_num + 1, sol, x_move, y_move, N):
                return True

            # Nếu không tìm thấy giải pháp, trả lại giá trị ban đầu cho ô hiện tại
            sol[next_x][next_y] = -1

    # Nếu không có bước đi nào hợp lệ, trả về False
    return False
n=int(input("Nhập vaò kích cỡ bàn cờ: "))
solve_knight_tour(n)

"""**BT06** Bài toán 8 con hậu"""

def can_place(board, row, col):
    for i in range(row):
        if board[i] == col or \
           board[i] - i == col - row or \
           board[i] + i == col + row:
            return False
    return True

def solve(board, row):
    if row == len(board):
        return True

    for col in range(len(board)):
        if can_place(board, row, col):
            board[row] = col
            if solve(board, row + 1):
                return True
            board[row] = -1

    return False

def print_board(board):
    for row in range(len(board)):
        line = ""
        for col in range(len(board)):
            if board[row] == col:
                line += "1 "
            else:
                line += "0 "
        print(line)
    print()

n=int(input("Nhập vào kích cỡ bàn phím: "))
board = [-1] * n
solve(board, 0)
print_board(board)

"""**2.** **Danh sách liên kết**

**BT01** Danh sách liên kết đơn
"""

class Node:
    def __init__(self, val=None):
        self.val = val

"""**BT02** Danh sách liên kết kép"""

class Node:
    def __init__(self, val=None):
        self.val = val
        self.prev = None
        self.next = None


class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def add_node(self, val):
        new_node = Node(val)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

    def print_list(self):
        curr_node = self.head
        while curr_node is not None:
            print(curr_node.val, end=" ")
            curr_node = curr_node.next

doubly_linked_list = DoublyLinkedList()
doubly_linked_list.add_node(1)
doubly_linked_list.add_node(2)
doubly_linked_list.add_node(3)
doubly_linked_list.print_list()

"""**BT03** Ngăn xếp – Stack"""

class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.size())
print(s.pop())
print(s.pop())
print(s.is_empty())
print(s.pop())
print(s.is_empty())

"""**BT04** Hàng đợi – Queue"""

import queue

# Tạo một hàng đợi rỗng với kích thước tối đa là 5
q = queue.Queue(maxsize=5)

# Thêm các phần tử vào hàng đợi
q.put(1)
q.put(2)
q.put(3)
q.put(4)
q.put(5)

# Hiển thị số lượng phần tử trong hàng đợi
print("Số phần tử trong hàng đợi là:", q.qsize())

# Lấy các phần tử ra khỏi hàng đợi và in ra màn hình
while not q.empty():
    print(q.get())

# Hiển thị số lượng phần tử trong hàng đợi sau khi đã lấy ra tất cả các phần tử
print("Số phần tử trong hàng đợi sau khi lấy ra là:", q.qsize())

"""**3. Mô hình cây**

**BT01** Cây – Duyệt theo thứ tự trước
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class Tree:
    def __init__(self):
        self.root = None

    def pre_order(self, node):
        if node:
            print(node.data)
            self.pre_order(node.left)
            self.pre_order(node.right)

tree = Tree()
tree.root = Node(1)
tree.root.left = Node(2)
tree.root.right = Node(3)
tree.root.left.left = Node(4)
tree.root.left.right = Node(5)

print("Pre-order traversal of binary tree is:")
tree.pre_order(tree.root)

"""**BT02** Cây – Duyệt theo thứ tự sau"""

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None


def create_tree():
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    return root


def pre_order_traversal(node):
    if node:
        print(node.value)
        pre_order_traversal(node.left)
        pre_order_traversal(node.right)


# Tạo cây
root = create_tree()

# In cây theo thứ tự trước
pre_order_traversal(root)

"""**BT03** Thuật toán Kruskal"""

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            if self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            elif self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1

def kruskal(n, edges):
    uf = UnionFind(n)
    mst = []
    edges.sort(key=lambda x: x[2])  # Sắp xếp các cạnh theo trọng số

    for u, v, weight in edges:
        if uf.find(u) != uf.find(v):
            uf.union(u, v)
            mst.append((u, v, weight))

    return mst

# Ví dụ sử dụng
n = 6  # Số đỉnh
edges = [
    (0, 1, 4),
    (0, 2, 4),
    (1, 2, 2),
    (1, 3, 5),
    (2, 3, 5),
    (2, 4, 11),
    (3, 4, 9),
    (3, 5, 2),
    (4, 5, 6)
]

mst = kruskal(n, edges)
print("Cây khung nhỏ nhất (MST):")
for u, v, weight in mst:
    print(f"({u}, {v}) - Trọng số: {weight}")

"""**BT04** Thuật toán Dijkstra"""

import heapq

def dijkstra(graph, start):
    # Khởi tạo khoảng cách từ đỉnh nguồn đến tất cả các đỉnh khác là vô cực
    distances = {vertex: float('infinity') for vertex in graph}
    # Khoảng cách từ đỉnh nguồn đến chính nó là 0
    distances[start] = 0
    # Khởi tạo priority queue
    priority_queue = [(0, start)]

    while priority_queue:
        # Lấy đỉnh có khoảng cách nhỏ nhất từ priority queue
        current_distance, current_vertex = heapq.heappop(priority_queue)

        # Bỏ qua các đỉnh đã có khoảng cách tối ưu
        if current_distance > distances[current_vertex]:
            continue

        # Cập nhật khoảng cách của các đỉnh kề
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight

            # Nếu tìm thấy khoảng cách ngắn hơn, cập nhật và thêm vào priority queue
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances

# Ví dụ sử dụng
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

start_vertex = 'A'
distances = dijkstra(graph, start_vertex)
print(f"Khoảng cách ngắn nhất từ đỉnh {start_vertex} đến các đỉnh khác:")
for vertex, distance in distances.items():
    print(f"{vertex}: {distance}")

"""**4. Đồ Thị**

**BT01** Đồ thị vô hướng
"""

import networkx as nx
import matplotlib.pyplot as plt

# Tạo đồ thị
G = nx.Graph()

# Thêm các đỉnh vào đồ thị
G.add_nodes_from([1, 2, 3, 4, 5])

# Thêm các cạnh vào đồ thị
G.add_edges_from([(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)])

# Vẽ đồ thị
nx.draw(G, with_labels=True)
plt.show()

"""**BT02** Đồ thị có hướng"""

import networkx as nx
import matplotlib.pyplot as plt

# Tạo một đối tượng đồ thị
G = nx.DiGraph()

# Thêm các đỉnh
G.add_nodes_from(range(1, 6))

# Thêm các cạnh
G.add_edges_from([(1, 2), (2, 3), (3, 1), (3, 4), (4, 5), (5, 3), (5, 2)])

# Vẽ đồ thị
nx.draw(G, with_labels=True)

# Hiển thị đồ thị
plt.show()

"""**5. Sắp xếp và tìm kiếm**

**BT01** Thuật toán sắp xếp chọn
"""

def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

arr = [64, 25, 12, 22, 11]
print(selection_sort(arr))

"""**BT02** Thuật toán sắp xếp chèn"""

def insertion_sort(arr):
    # Vòng lặp bắt đầu từ phần tử thứ hai của mảng
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # Di chuyển các phần tử có giá trị lớn hơn giá trị khóa đến một vị trí trước
        # vị trí hiện tại của nó trong mảng sắp xếp.
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        # Chèn giá trị khóa vào vị trí đúng trong mảng sắp xếp
        arr[j + 1] = key
    return arr

# ví dụ sử dụng
arr = [12, 11, 13, 5, 6]
sorted_arr = insertion_sort(arr)
print("Mảng đã sắp xếp: ", sorted_arr)

"""**BT03** Thuật toán sắp xếp nổi bọt"""

def bubbleSort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr

# Khởi tạo một mảng
arr = [64, 34, 25, 12, 22, 11, 90]

# Sắp xếp mảng
sorted_arr = bubbleSort(arr)

# In kết quả
print("Mảng đã sắp xếp là:")
for i in range(len(sorted_arr)):
    print("%d" %sorted_arr[i])

"""**BT04** Thuật toán sắp xếp nhanh – quick sort"""

def quicksort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        left = []
        right = []
        for i in range(1, len(arr)):
            if arr[i] < pivot:
                left.append(arr[i])
            else:
                right.append(arr[i])
        return quicksort(left) + [pivot] + quicksort(right)

# ví dụ sử dụng
arr = [5, 2, 8, 4, 7, 6, 1, 3]
print("Before sorting: ", arr)
arr = quicksort(arr)
print("After sorting: ", arr)

"""**BT05** Thuật toán heat sort"""

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

    return arr

# Example usage
arr = [12, 11, 13, 5, 6, 7]
sorted_arr = heap_sort(arr)
print(sorted_arr)

"""**BT06** Thuật toán sắp xếp trộn – merge sort"""

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        # Recursive call on each half
        merge_sort(left_half)
        merge_sort(right_half)

        # Merge the two sorted halves
        i = j = k = 0
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

    return arr

# Example usage
arr = [38, 27, 43, 3, 9, 82, 10]
sorted_arr = merge_sort(arr)
print(sorted_arr)